# -*- coding: utf-8 -*-
"""Vectores 2D y 3D

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1dngdMBEiz_kOjLJI49czU1eCVtm9BleT
"""

# Importamos el módulo necesario para crear clases abstractas
from abc import ABC, abstractmethod

# Paso 1: Definir la INTERFAZ BASE para vectores
class Vector(ABC):
    # Método abstracto para obtener el valor del vector (tupla)
    @abstractmethod
    def get_value(self):
        pass

    # Método abstracto para sumar este vector con otro
    @abstractmethod
    def add(self, other):
        pass

# Paso 2: Crear la clase Vector2D que hereda de Vector
class Vector2D(Vector):
    def __init__(self, x: float, y: float):
        # Guardamos los valores x y y
        self.x = x
        self.y = y

    def get_value(self):
        # Devolvemos el valor como tupla (x, y)
        return (self.x, self.y)

    def add(self, other):
        # Verificamos si el otro vector también es 2D
        if isinstance(other, Vector2D):
            # Sumamos componente a componente y devolvemos un nuevo Vector2D
            return Vector2D(self.x + other.x, self.y + other.y)
        else:
            # Si el otro no es Vector2D, lanzamos error
            raise TypeError("No se puede sumar un vector 2D con un vector 3D")

    def __str__(self):
        # Para imprimir bonito el vector 2D
        return f"Vector2D({self.x}, {self.y})"

# Paso 3: Crear la clase Vector3D que hereda de Vector
class Vector3D(Vector):
    def __init__(self, x: float, y: float, z: float):
        # Guardamos los valores x, y y z
        self.x = x
        self.y = y
        self.z = z

    def get_value(self):
        # Devolvemos el valor como tupla (x, y, z)
        return (self.x, self.y, self.z)

    def add(self, other):
        # Verificamos si el otro vector también es 3D
        if isinstance(other, Vector3D):
            # Sumamos componente a componente y devolvemos un nuevo Vector3D
            return Vector3D(self.x + other.x, self.y + other.y, self.z + other.z)
        else:
            # Si el otro no es Vector3D, lanzamos error
            raise TypeError("No se puede sumar un vector 3D con un vector 2D")

    def __str__(self):
        # Para imprimir bonito el vector 3D
        return f"Vector3D({self.x}, {self.y}, {self.z})"

# Paso 4: Función que suma una lista de vectores
def sum_vectors(vectors: list[Vector]):
    # Si la lista está vacía, devolvemos None
    if not vectors:
        return None

    # Comenzamos con el primer vector como total inicial
    total = vectors[0]

    # Sumamos uno por uno con el resto de la lista
    for v in vectors[1:]:
        total = total.add(v)

    # Devolvemos la suma total
    return total

# Paso 5: Probar el código

# Creamos dos vectores 2D
v2d_1 = Vector2D(1, 2)
v2d_2 = Vector2D(3, 4)

# Creamos dos vectores 3D
v3d_1 = Vector3D(1, 1, 1)
v3d_2 = Vector3D(2, 2, 2)

# Sumamos vectores 2D usando la función sum_vectors
sum_2d = sum_vectors([v2d_1, v2d_2])
print(f"Suma de vectores 2D: {sum_2d}")  # Debería ser Vector2D(4, 6)

# Sumamos vectores 3D usando la función sum_vectors
sum_3d = sum_vectors([v3d_1, v3d_2])
print(f"Suma de vectores 3D: {sum_3d}")  # Debería ser Vector3D(3, 3, 3)

# Intentamos sumar un vector 2D con uno 3D (debe dar error)
try:
    v2d_1.add(v3d_1)
except TypeError as e:
    print(f"Error al sumar vectores mixtos: {e}")